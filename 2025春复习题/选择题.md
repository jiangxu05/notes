
# 基础

---

【单选题】已知类声明如下"class A{ int a;};"，则类A的数据成员a的访问权限是_____。（6.0分）  
A. protected  
B. public  
C. private  
D. 不确定  

**答案：C**  

---

【单选题】在一个类的定义中，包含有【】成员的定义。（6.0分）  
A. 数据和函数  
B. 函数  
C. 数据  
D. 数据或函数  

*我的答案：A*  

---

【单选题】假定A为一个类，int a()为该类的一个公有成员函数，x为A类的一个对象（A x;），则调用x对象中的函数成员a的格式为【   】。（6.0分）  
A. x.a  
B. int x.a  
C. x.a()  
D. int x.a()  

**答案：C**  

---

【单选题】当一个类对象生命期结束时，系统自动调用_____并销毁对象。（6.0分）  
A. 构造函数  
B. 静态函数  
C. 友元函数  
D. 析构函数  

**答案：D**  

---


【单选题】在C/C++语言的函数中，关于形参（形式参数）的下面几个说法，正确的是【】  
A. 形参不需要类型  
B. 必须有形参  
C. 形参可以有也可以没有  
D. 形参必须是具体的值  

**答案：C**  

---

【单选题】判断字符串s1是否大于字符串s2，应当使用【】。  
A. if (strcmp(s1,s2))  
B. if (strcmp(s2,s1)>0)  
C. if (s1>s2)  
D. if (strcmp(s1,s2)>0)  

**答案：D**  

---

【单选题】下列关于C++函数的说明中，正确的是【】。  
A. 编译器会根据函数的参数个数和参数类型来区分函数的重载形式  
B. 内联函数就是定义在另一个函数体内部的函数  
C. 标准C++要求在调用一个函数之前，必须先声明其原型  
D. 函数体的最后一条语句必须是return语句  

```cpp
// 解析：
// A. 正确。函数重载依据参数列表（个数/类型/顺序）
// B. 错误。inline是编译优化建议，与定义位置无关
// C. 错误。仅当函数定义在调用之后时需要声明
// D. 错误。void函数可不返回，非void需保证所有路径返回
**答案：A**
```

---

【单选题】是break在实际应用中最常用、最有效的写法。  
A. break直接用在循环语句中，作用是跳出循环  
B. break用在循环语句中的if语句，作用是满足条件时跳出本次循环，进行下一次循环条件  
C. break直接用在if语句中，作用是跳出if语句  
D. break用在循环语句中的if语句，作用是满足条件时跳出循环  

```cpp
// 示例：
for (int i = 0; i < 100; i++) {
    if (array[i] == target) {
        break; // 条件满足时跳出整个循环
    }
}
```

**正确答案：D**  
> 关键点：  
> - break需配合条件判断使用（90%场景）  
> - 与continue区分：break终止循环，continue跳过本次迭代  
> - 必须位于循环/switch语句内部



【单选题】  
给出以下定义：  
```cpp
char x[] = "abcdefg";
char y[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g'};
```  
则正确的叙述为【 】。  

- **选项A**  
  数组x的长度大于数组y的长度  
- **选项B**  
  数组x的长度小于数组y的长度  
- **选项C**  
  数组x和数组y等价  
- **选项D**  
  数组x和数组y的长度相同  

> 我的答案：B  
> ✅ **正确答案：A**  

### 数组定义分析
```cpp
// x的存储内容（字符串自动补\0）
{'a','b','c','d','e','f','g','\0'} 
// 长度计算：7字符 + 1结束符 = 8

// y的存储内容（显式初始化无结束符）
{'a','b','c','d','e','f','g'}
// 长度计算：7字符
```

### 选项对比
- A✅：`sizeof(x)=8` > `sizeof(y)=7`  


# 指针

## 题目 1
【单选题】定义实型变量a和指针p，要让p指向a，以下不正确的有【】。

### 选项分析
- **选项A**
  ```c
  double a = 5;
  double *p;
  p = &a;
  ```
> 先把实型变量a定义好并赋值为 5，接着定义一个指向 double 类型的指针p，最后让指针p指向变量a的地址。

- **选项B**
  ```c
  double a = 5;
  double *p = &a;
  ```
> 在定义实型变量a并赋值为 5 之后，在定义指针p的同时就将其初始化为变量a的地址。

- **选项C**
  ```c
  double a = 5;
  double *p;
  *p = &a;  // [!error]
  ```
> 先定义实型变量a并赋值为 5，再定义指针p，然而错误地把a的地址赋给了p所指向的内存位置（*p）。
> 错误点：指针p在使用之前没有被初始化，它指向的是一个随机的内存地址，直接对其解引用会造成内存访问越界。
> double a = 5.0;  // a的值=5.0，地址=&a（0x7ffe53a0）
> double *p;       // p的值=随机地址（如0x0）
> *p = &a;         // 错误！试图将&a（0x7ffe53a0）写入p指向的随机内存
> // 最终：p仍指向随机地址，*p（随机内存）被错误赋值为0x7ffe53a0

- **选项D**
  ```c
  double a = 5, *p = &a;
  ```
> 在同一行里定义了实型变量a和指针p，并且在定义指针p时就将其初始化为变量a的地址。

- **选项E**
  ```c
  double a = 5, *p;
  p = &a;
  ```
> 在同一行定义实型变量a和指针p之后，再让指针p指向变量a的地址。
---

## 题目2
【单选题】下面函数的功能为【】。

```c
void swap(int *p1, int *p2) 
{ 
    int t;
    t = *p1;
    *p1 = *p2; 
    *p2 = t; 
}
```

### 选项
- **A** 交换 *p1 和 *p2 的值  
- **B** 可能造成系统故障，因为使用了空指针  
- **C** 交换 *p1 和 *p2 的地址  
- **D** 正确，但无法改变 *p1 和 *p2 的值  

---

## 答案解析
✅ 正确答案：A（交换 *p1 和 *p2 的值）**

### 完整解析

#### 1. 函数功能分析
**参数分析**：
```c
int *p1, int *p2  // 接收两个整型指针
```

**执行流程**：
1. `int t;`：声明临时整型变量
2. `t = *p1;`：保存p1指向的值
3. `*p1 = *p2;`：将p2的值赋给p1指向的内存
4. `*p2 = t;`：将临时值赋给p2指向的内存


#### 2. 选项正确性分析
- **选项A正确**：
  - 通过解引用操作交换指针指向的值
  - 典型用例：
    ```c
    int a=10, b=20;
    swap(&a, &b);  // a=20, b=10
    ```

- **选项B错误**：
  - 空指针问题是调用时的风险，非函数本身功能
  - 功能描述应聚焦设计意图而非使用风险

- **选项C错误**：
  - 混淆概念：`*p1`表示值，`p1`表示地址
  - 函数没有修改指针变量本身存储的地址

- **选项D错误**：
  - 自相矛盾：若函数正确则必然能改变值
  - 通过指针解引用直接修改内存内容

#### 3. 关键知识点总结
1. **指针操作本质**：
   ```c
   *p1 = ...  // 修改指针指向的内存内容
   p1 = ...   // 修改指针本身存储的地址
   ```

2. **正确调用方式**：
   ```c
   int x=5, y=10;
   swap(&x, &y);  // 必须传递有效内存地址
   ```
## 题目3
【单选题】下面程序的输出结果为【】。

```cpp
int fun(char *s) 
{   
    char *p = s; 
    while(*p != 0)  
        p++; 
    return (p - s); 
}

int main()
{   
    char str[] = "dev-c++";
    cout << fun(str) << endl;
    return 0;
}
```

### 选项
- **A** 3  
- **B** 7  
- **C** 1  
- **D** 语法错误  

---

## 答案解析
✅ **正确答案：B（7）**

### 题目讲解
本题考查C++中指针和字符串操作的知识。程序定义了一个函数`fun`用于计算字符串长度（不包括结尾空字符），并在`main`函数中输出结果。

#### 1. 函数功能分析
**参数**：
```cpp
char *s  // 指向字符串开头的指针
```

**执行流程**：
1. `char *p = s;`：声明指针p并初始指向字符串起始位置
2. `while(*p != 0)`：循环检查p指向的字符是否为空字符'\0'
3. `p++;`：将指针p向后移动一个字符
4. `return (p - s);`：返回指针差值（字符个数）

#### 2. main函数执行过程
```cpp
char str[] = "dev-c++";  // 实际存储：d e v - c + + \0
```
- 字符串可见字符7个，结尾隐式包含空字符
- `fun(str)`调用过程：
  - s指向'd'的位置（地址0）
  - p经过7次移动到达'\0'的位置（地址7）
  - 指针差值：7 - 0 = 7

#### 3. 选项分析
- **B正确**：
  - 字符串"dev-c++"实际长度7字符
  - 函数正确返回指针移动次数

- **A错误**：
  - 误判字符串为"dev"（实际是"dev-c++"）

- **C错误**：
  - 无对应逻辑关系

- **D错误**：
  - 代码语法正确（标准输出和字符串定义规范）

## 题目4
【单选题】如果要动态分配一个能存储1个int型变量的内存单元，初值为5，以下正确的是【】。

### 选项
- **A**  
  ```cpp
  int *p = new int<5>;
  ```
  
- **B**  
  ```cpp
  int *p = new int{5};
  ```

- **C**  
  ```cpp
  int *p = new int(5);
  ```

- **D**  
  ```cpp
  int *p = new int[5];
  ```

---

## 答案解析
✅ **正确答案：B、C（根据C++版本不同）**

### 选项分析
**选项A**：
```cpp
int *p = new int<5>;  // [!error]
```
- ❌ 语法错误：尖括号`< >`用于模板参数（如`new vector<int>(5)`）
- ➥ 混淆了模板实例化与动态内存初始化语法

**选项B**：
```cpp
int *p = new int{5};
```
- ✅ C++11起支持的列表初始化（uniform initialization）
- ✔️ 正确分配单个int并初始化为5

**选项C**：
```cpp
int *p = new int(5);
```
- ✅ 传统C++标准初始化方式
- ✔️ 正确分配单个int并初始化为5

**选项D**：
```cpp
int *p = new int[5];
```
- ❌ 分配包含5个int的数组
- ➥ 不符合"单个int变量"要求，且未设置初值5

---

## 关键知识点
1. **new运算符初始化方式**：
   ```cpp
   new int(5);   // 传统括号初始化
   new int{5};   // C++11列表初始化
   ```

2. **错误类型辨析**：
   - `< >` → 模板参数专用
   - `[ ]` → 数组分配标识
   - 未初始化 → 如`new int`会得到随机值

---

## 补充说明
1. **版本兼容性**：
   - C++11及以上：B、C都正确
   - 传统C++：仅C正确

2. **执行效果**：
   ```cpp
   int *p1 = new int(5);  // *p1 == 5
   int *p2 = new int{5};  // *p2 == 5 (C++11+)
   ```

3. **建议选择**：
   - 考试环境不确定时选**C**（兼容所有版本）
   - 现代C++开发可同时接受B、C






### 题目7
【单选题】`float *p = new float[10];`下面对应的delete用法正确的是【】。

- **A**  
  ```cpp
  delete p[10];
  ```

- **B**  
  ```cpp
  delete p;
  ```

- **C**  
  ```cpp
  delete float;
  ```

- **D**  
  ```cpp
  delete[] p;
  ```

---

## 题目解析
**考查重点**：C++动态内存释放的正确语法，区分`delete`和`delete[]`的用法

### 关键知识点
1. **内存操作对比表**：
   | 分配方式                | 正确释放方式  | 错误释放后果                  |
   |-----------------------|-------------|----------------------------|
   | `new float[10]`（数组） | `delete[] p` | 完整释放10个float的内存       |
   | `new float`（单个变量） | `delete p`   | 释放单个float的内存           |
   | 错误示例（如选项C）      | -           | 编译失败                     |

2. **语法规则**：
   - `new[]`和`delete[]`必须配对使用
   - `delete`后必须跟指针变量名，不能是类型名

### 选项分析
**选项A**：
```cpp
delete p[10];  // [!error]
```
- ❌ 双重错误：
  1. 下标越界（有效范围是p[0]~p[9]）
  2. 语法错误（delete操作对象必须是指针）

**选项B**：
```cpp
delete p;  // [!error]
```
- ❌ 类型不匹配：
  - 数组分配应使用`delete[]`
  - 仅释放第一个元素内存，造成内存泄漏

**选项C**：
```cpp
delete float;  // [!error]
```
- ❌ 语法错误：
  - 操作对象必须是变量指针
  - 不能直接使用类型名

**选项D**：
```cpp
delete[] p;  // ✅
```
- ✔️ 完全正确：
  - 精确匹配数组释放方式
  - 完整释放10个float的内存空间

---

## 正确答案
✅ **正确答案：D（delete[] p）**

💡 **记忆技巧**：
> `new[]`和`delete[]`的方括号`[]`就像数组的"身份证"，必须成对出现！此知识点是C++面试高频考点，务必掌握匹配原则以避免内存泄漏。

---

## 补充说明
1. **最佳实践**：
   ```cpp
   // 分配与释放严格对应
   float* arr = new float[10];  // 分配数组
   // ...使用数组...
   delete[] arr;                // 正确释放

   float* val = new float;      // 分配单个变量
   // ...使用变量...
   delete val;                  // 正确释放
   ```

## 题目8
【单选题】下面函数中，无法实现主调函数交换两个整数的值的功能的是【】。

### 选项
- **A**  
  ```cpp
  void fun1(int& x, int& y) {
      int temp = x;
      x = y;
      y = temp;
  }
  ```

- **B**  
  ```cpp
  void fun4(int* x, int* y) {
      int* temp = new int;
      *temp = *x;
      *x = *y;
      *y = *temp;
  }
  ```

- **C**  
  ```cpp
  void fun3(int x, int y) {
      int temp = x;
      x = y;
      y = temp;
  }
  ```

- **D**  
  ```cpp
  void fun2(int* x, int* y) {
      int temp = *x;
      *x = *y;
      *y = temp;
  }
  ```

---

## 题目解析
**考查重点**：函数参数传递方式对变量交换的影响

### 选项分析
- **选项A**  
  ✅ **正确实现**  
  ```cpp
  void fun1(int& x, int& y)  // 引用传递（直接操作原变量）
  ```
  - x 和 y 是实参的别名
  - 交换操作直接影响主调函数中的变量

- **选项B**  
  ✅ **功能正确但存在内存泄漏**  
  ```cpp
  void fun4(int* x, int* y)  // 指针传递（通过地址修改原值）
  ```
  - `*x` 和 `*y` 解引用操作直接修改指针指向的内存
  - 问题：`new int`未释放，但交换功能正确

- **选项C**  
  ❌ **无法实现交换**  
  ```cpp
  void fun3(int x, int y)  // 值传递（操作的是副本）
  ```
  - 函数内交换的只是形参副本
  - 不影响主调函数的实参

- **选项D**  
  ✅ **正确实现**  
  ```cpp
  void fun2(int* x, int* y)  // 指针传递（通过地址修改原值）
  ```
  - `*x` 和 `*y` 解引用操作直接修改原变量

---

### 关键对比表
| 选项 | 参数类型      | 内存操作方式               | 能否交换 |
|------|-------------|--------------------------|--------|
| A    | int&（引用） | 直接操作原始变量           | ✅      |
| B    | int*（指针） | 解引用修改指针目标值       | ✅      |
| C    | int（值）    | 操作副本，不影响原始值     | ❌      |
| D    | int*（指针） | 解引用修改指针目标值       | ✅      |

---

### 常见错误分析
1. **值传递陷阱（选项C）**：
   ```cpp
   int a=1, b=2;
   fun3(a, b);  // 调用后 a仍为1, b仍为2
   ```

2. **正确用法对比**：
   ```cpp
   fun1(a, b);    // 引用：a=2, b=1
   fun2(&a, &b);  // 指针：a=2, b=1
   fun4(&a, &b);  // 指针：a=2, b=1（有内存泄漏但结果正确）
   ```

---

## 正确答案
✅ **正确答案：C（fun3）**

> 📌 **核心原则**：  
> 要修改主调函数的变量，必须传递变量的地址（指针）或别名（引用）。值传递只能读取原始值，无法写入修改。其他选项都能实现交换，只有C无法实现。

### 1. 若已定义：`int a[5]={1,2,3,4,5},*p=a;`且p值未发生变化，下列不能表示a[1]地址的是（  ）。  
**A. p+1**  
**B. a+1**  
**C. a++**  
**D. ++p**  

**答案：C**  
**题解**：  
- **A. p+1**：`p`指向`a[0]`，`p+1`指向`a[1]`，合法。  
- **B. a+1**：数组名`a`是常量指针，`a+1`指向`a[1]`，合法。  
- **C. a++**：数组名是常量，不能执行自增操作，**非法**。  
- **D. ++p**：`p`是变量指针，`++p`后指向`a[1]`，但题目要求`p`值未变化，此处假设为语法判断，若执行则`p`值改变，但若仅分析表达式，`++p`本身可表示`a[1]`的地址，合法。  


### 2. 有以下程序段：  
```cpp
int a[]={10,9,8,7,6,5,4,3,2,1}, *p;
p=a;
printf("%d,%d", *p+9, *(p+9) );
```  
输出结果为（    ）。  
**A. 1,1**  
**B. 19,10**  
**C. 19,1**  
**D. 19,19**  

**答案：C**  
**题解**：  
- `*p+9`：`*p`即`a[0]`（值为10），加9后得19。  
- `*(p+9)`：`p+9`指向`a[9]`，解引用得1。  
输出：`19,1`。  


### 3. 以下程序段的输出结果为（    ）。  
```cpp
int m=20,*p=&m; 
*p=10;
printf("%d,%d",m,*p);
```  
**A. 20,10**  
**B. 10,10**  
**C. 20,20**  
**D. 10,20**  

**答案：B**  
**题解**：  
- `*p=10`：通过指针修改`m`的值为10。  
- `m`和`*p`均为10，输出：`10,10`。  


### 4. 下列语句定义x为指向int类型变量a的指针，正确的是（ ）。  
A. int a,*x=a 
B. int a,*x=&a
C. int *x=&a,a
D. int a,x=a 

**答案：B**  
**题解**：  
- **A**：指针`x`应初始化为`&a`（`a`的地址），而非`a`（值），错误。  
- **B**：先定义`a`，再用`&a`初始化`x`，正确。  
- **C**：变量`a`在`&a`后才定义，非法。  
- **D**：`x`被定义为`int`，而非指针，错误。  


### 5. 若有`int *p,a=4;`和`p=&a;`，下面（    ）均代表地址。  
A. a,p,*&a  
B. &*a,&a,*p
C. *&p,*p,&a
D. &a,&*p,p

**答案：D**  
**题解**：  
- **A**：`a`是值（4），`p`是地址，`*&a`等价于`a`（值），不都代表地址。  
- **B**：`&*a`非法（`a`不是指针），`&a`是地址，`*p`是值（4），错误。  
- **C**：`*&p`等价于`p`（地址），`*p`是值（4），`&a`是地址，不都代表地址。  
- **D**：`&a`是`a`的地址，`&*p`等价于`p`（地址），`p`是地址，均代表地址，正确。



# 考前练习- 解析来自豆包

### 1. 执行下面程序段，给x、y赋值时，不能作为数据分隔符的是_____。  
```cpp
int x,y;
cin >> x >> y;
```  
**A. 回车**  
**B. 空格**  
**C. Tab键**  
**D. 逗号**  

**答案：D**  
**题解**：在C++中，`cin`使用空白符（空格、回车、Tab键）作为输入数据的分隔符，而逗号不属于空白符，无法作为分隔符。因此输入时若用逗号分隔数据会导致读取失败。


### 2. C/C++语言中，运算对象必须是整型数的运算符是【 】。  
**A. /**  
**B. %和/**  
**C. ***  
**D. %**  

**答案：D**  
**题解**：`%`（取模运算符）要求左右操作数必须为整型，而`/`（除法运算符）、`*`（乘法运算符）可以用于浮点型和整型。例如，`5 % 2`合法，而`5.0 % 2.0`会编译错误。


### 3. 高级语言编写的程序相比机器语言编写的特点是_____。  
**A. 计算机能直接识别和执行**  
**B. 执行速度快**  
**C. 可读性好，语法更接近自然语言**  
**D. 依赖于具体机器，移植性差**  

**答案：C**  
**题解**：高级语言（如C++）用更接近自然语言的语法编写，可读性强，但需要编译成机器语言才能执行，执行速度比机器语言慢，且移植性好（不依赖具体硬件）。机器语言直接由0和1组成，计算机可直接执行，但可读性差、移植性差。



### 5. 把源程序文件翻译转换成目标文件的过程叫做_____。  
**A. 编译**  
**B. 编辑**  
**C. 连接**  
**D. 调试**  

**答案：A**  
**题解**：编译过程将源程序（.cpp）转换为目标文件（.obj），链接过程将目标文件和库文件合并为可执行文件（.exe）。编辑是编写代码的过程，调试是查找错误的过程。


### 6. 表达式`10+'a'+1.5-567.345/'b'`的结果类型是(  )。  
**A. unsigned float**  
**B. int**  
**C. long**  
**D. double**  

**答案：D**  
**题解**：表达式中包含多种类型：`10`（int）、`'a'`（char，转为int为97）、`1.5`（double）、`567.345`（double）、`'b'`（char，转为int为98）。根据C++类型转换规则，所有操作数会向最高精度类型`double`转换，最终结果为`double`类型。


### 7. 下列字符串可以作为标识符的是_____。  
**A. long**  
**B. INT**  
**C. !DF**  
**D. 5_student**  

**答案：B**  
**题解**：标识符规则：以字母或下划线开头，由字母、数字、下划线组成，不能是关键字。  
- `long`是C++关键字，不能作为标识符；  
- `INT`是合法标识符（大写字母允许）；  
- `!DF`包含非法字符`!`；  
- `5_student`以数字开头，非法。


### 8. 下面关于C/C++语言注释的描述中，正确的是_____。  
**A. 以"/* "开始的单行注释**  
**B. 以"/*"开始，以"//"结束的块式注释**  
**C. 以"//"开始和结束的块式注释**  
**D. 以 "/*" 开始，以 "*/"结束的块式注释**  

**答案：D**  
**题解**：C++有两种注释方式：  
- 单行注释：以`//`开头，到行尾结束；  
- 块注释：以`/*`开头，以`*/`结束，可跨多行。  


### 9. 假定`int a = 3, b = 2;`，则表达式`1.0 * a / b`的值是(  )。  
**A. 1.5**  
**B. 1.0**  
**C. 2**  
**D. 1**  

**答案：A**  
**题解**：`1.0`是double类型，`1.0 * a`会将`a`（int）转为double，得到`3.0`，再除以`b`（2），结果为`1.5`。若表达式为`a / b`，则结果为1（整数除法）。


### 10. 设`d`为字符变量，下列表达式中不正确的是【 】。  
**A. d=110**  
**B. d="n"**  
**C. d='n'**  
**D. d='\n'**  

**答案：B**  
**题解**：字符变量赋值规则：  
- `d=110`：合法，110是ASCII码值（对应字符`'n'`）；  
- `d="n"`：错误，`"n"`是字符串（char[2]），不能赋值给字符变量（char）；  
- `d='n'`：合法，单引号包裹单个字符；  
- `d='\n'`：合法，`\n`是转义字符（换行符）。



### 12. else语句嵌套使用时，C/C++语言规定，else总是与(  )配对。  
**A. 距离最近的if**  
**B. 其前面最近的if**  
**C. 缩排位置相同的if**  
**D. 其前面最近的未配对的if**  

**答案：D**  
**题解**：在C/C++中，`else`与离它最近的未配对的`if`配对，与缩进无关。例如：  
```cpp
if (a) if (b) cout << 1; else cout << 2;
```  
其中`else`与第二个`if`配对，而非第一个`if`。


### 13. 假设有如下的程序片段，若`grade`的值为'C'，则输出结果是_____。  
```cpp
switch(grade) {
    case 'A': cout << "GREAT!";
    case 'B': cout << "GOOD!";
    case 'C': cout << "OK!";
    case 'D': cout << "NO!";
    default : cout << "ERROR!";
}
```  
**A. OK!**  
**B. GREAT!GOOD!OK!NO!ERROR!**  
**C. 不确定**  
**D. OK!NO!ERROR!**  

**答案：D**  
**题解**：`switch`语句中，若case后无`break`，会继续执行后续所有case。当`grade='C'`时，从`case 'C'`开始执行，输出`OK!`，然后继续执行`case 'D'`和`default`，输出`NO!ERROR!`，最终结果为`OK!NO!ERROR!`。


### 14. 阅读下面的程序：  
```cpp
#include<iostream>
using namespace std;
int main() {
    int a,b;
    cin >> a >> b;
    if(a>b) 
        a=b;b=a; 
    else 
        a++;b++; 
    cout << a << b;
    return 0;
}
```  
正确的说法是（  ）。  
**A. 有语法错误不能通过编译**  
**B. 若输入5,4则输出4,5**  
**C. 若输入4,5则输出5,6**  
**D. 若输入5,4则输出5,5**  

**答案：A**  
**题解**：`if(a>b) a=b;b=a;`中，`if`语句只控制`a=b;`，`b=a;`是独立语句，无论`if`条件是否成立都会执行。正确的语法应为用花括号包裹多个语句：  
```cpp
if(a>b) { a=b; b=a; }
```  
否则会导致逻辑错误，且代码存在语法错误（非预期的语句结构），无法通过编译。


### 15. 下面表达式与`max = (a>b) ? a : b;`表示的作用不同的是（  ）。  
**A. max = b; if(a > b) max = a;**  
**B. max = a; if(a < b) max = b;**  
**C. if( a> b) max = a; else max = b;**  
**D. if( a> b) max = b; else max = a;**  

**答案：D**  
**题解**：原表达式`(a>b) ? a : b`表示取`a`和`b`中的较大值。  
- A、B、C选项均实现取较大值；  
- D选项中，若`a>b`则取`b`，否则取`a`，实际取较小值，与原表达式逻辑相反。


### 16. 下面的程序段执行后，x 的值是【 】。  
```cpp
int a = 9, b = 7, c = 3, d = 5, x;
x = a > b ? c : d;
```  
**A. 3**  
**B. 5**  
**C. 7**  
**D. 9**  

**答案：A**  
**题解**：条件表达式`a > b ? c : d`中，`a=9`，`b=7`，`a > b`为真，因此取`c`的值（3）赋给`x`。


### 17. 判断 char 型变量 s 是否为小写字母的正确表达式是(  )。  
**A. 'a' <= s<= 'z'**  
**B. (s>='a') & (s<='z')**  
**C. (s>='a') && (s<='z')**  
**D. ('a'<=s) and ('z'>=s)**  

**答案：C**  
**题解**：  
- A错误，C++不支持连续关系运算（`'a' <= s <= 'z'`会被解析为`('a' <= s) <= 'z'`，结果为0或1，与原意不符）；  
- B错误，`&`是按位与运算符，此处应使用逻辑与`&&`；  
- C正确，`&&`表示逻辑与，当`s`在`'a'`到`'z'`之间时为真；  
- D错误，C++中逻辑与运算符为`&&`，而非`and`（`and`是C++11后的关键字，等价于`&&`，但此处写法不规范）。


### 18. 假设有如下的程序片段，若`grade`的值为'C'，则输出结果是【 】。（同第13题）  
```cpp
switch(grade) {
    case 'A': cout << "GREAT!";
    case 'B': cout << "GOOD!";
    case 'C': cout << "OK!";
    case 'D': cout << "NO!";
    default : cout << "ERROR!";
}
```  
**A. OK!**  
**B. GREAT!GOOD!OK!NO!ERROR!**  
**C. 不确定**  
**D. OK!NO!ERROR!**  

**答案：D**  
**题解**：同第13题，无`break`时会继续执行后续case，输出`OK!NO!ERROR!`。


### 19. 下面程序段运行时的输出结果是（ ）。  
```cpp
grade='C';
switch(grade) {
    case 'A': printf("A");
    case 'B': printf("B");
    case 'C': printf("C");
    case 'D': printf("D");
    default : printf("ERROR");
}
```  
**A. C**  
**B. ABC**  
**C. DERROR**  
**D. CDERROR**  

**答案：D**  
**题解**：同第13题，`grade='C'`时从`case 'C'`开始执行，输出`C`，然后继续执行`case 'D'`和`default`，输出`DERROR`，最终结果为`CDERROR`。


### 20. while和do…while语句的主要区别是_____。  
**A. while的循环控制条件比do…while循环控制条件严格**  
**B. do…while允许使用break语句跳出循环，而while只能用continue跳出循环**  
**C. 当循环体包含多条语句时，do…while的循环体必须使用复合语句，而while循环体不需要使用复合语句**  
**D. do…while的循环体至少要无条件执行一次，而while可能一次都不执行**  

**答案：D**  
**题解**：  
- `while`先判断条件，再执行循环体，若条件初始为假，则循环体一次不执行；  
- `do…while`先执行循环体，再判断条件，因此循环体至少执行一次。  
两者均支持`break`和`continue`，循环体包含多条语句时均需用花括号包裹。


### 21. 下面语句中，while循环执行的次数是【 】次。  
```cpp
k=10; 
while(k=1) 
    k=k-10;
```  
**A. 无限**  
**B. 1**  
**C. 0**  
**D. 2**  

**答案：A**  
**题解**：`while(k=1)`中，`k=1`是赋值表达式，其值为1（真），因此循环条件恒为真，导致无限循环。若想判断`k`是否等于1，应使用`while(k==1)`。


### 22. 下面程序段执行时输出_____个字符#。  
```cpp
int i=1; 
while(1) {
    i++; 
    if(i==10) 
        break;
    if(i%2==0) 
        cout << "#"; 
}
```  
**A. 3**  
**B. 4**  
**C. 5**  
**D. 10**  

**答案：B**  
**题解**：循环过程：  
- `i=1`：进入循环，`i++`后`i=2`，`i%2==0`，输出`#`；  
- `i=2`：`i++`后`i=3`，不输出；  
- `i=3`：`i++`后`i=4`，输出`#`；  
- `i=4`：`i++`后`i=5`，不输出；  
- `i=5`：`i++`后`i=6`，输出`#`；  
- `i=6`：`i++`后`i=7`，不输出；  
- `i=7`：`i++`后`i=8`，输出`#`；  
- `i=8`：`i++`后`i=9`，不输出；  
- `i=9`：`i++`后`i=10`，触发`break`退出循环。  
共输出4次`#`。


### 23. 若i,j已定义为int型，则以下程序段中循环体总的执行次数是_____。  
```cpp
for(i=1; i<=5; i++)
    for(j=0; j<4; j++)
    { …… }
```  
**A. 25**  
**B. 30**  
**C. 24**  
**D. 20**  

**答案：D**  
**题解**：外层循环`i`从1到5，执行5次；内层循环`j`从0到3，每次执行4次。总次数为5×4=20次。


### 24. 下面代码段运行后，f的值为（  ）。  
```cpp
int f,f1=1,f2=1;
for(int i=3;i<=8;i++) {
    f=f1+f2;
    f1=f2;
    f2=f;
}
cout << f << " ";
```  
**A. 13**  
**B. 34**  
**C. 21**  
**D. 10**  

**答案：C**  
**题解**：这是斐波那契数列计算，初始`f1=1, f2=1`，循环从`i=3`到`i=8`：  
- `i=3`: f=1+1=2, f1=1, f2=2  
- `i=4`: f=1+2=3, f1=2, f2=3  
- `i=5`: f=2+3=5, f1=3, f2=5  
- `i=6`: f=3+5=8, f1=5, f2=8  
- `i=7`: f=5+8=13, f1=8, f2=13  
- `i=8`: f=8+13=21, f1=13, f2=21  
循环结束后`f=21`。
\

### 26. 有如下程序，编译运行这个程序将出现的情况是_____。  
```cpp
#include<iostream>
using  namespace std;
void f(double val);
int main() {
    double val;
    f(val);
    cout << val;
    return 0;
}
void f(double val) {
    val=3;
}
```  
**A. 输出:3**  
**B. 输出:3.0**  
**C. 输出一个不确定的数**  
**D. 编译出错,无法运行**  

**答案：C**  
**题解**：函数`f(double val)`采用值传递，修改的是形参`val`，实参`main`中的`val`未被修改。由于`val`在`main`中未初始化，输出值为不确定的随机数。f在这没有任何作用。


### 27. 函数的定义和函数的声明需要匹配，否则无法通过编译。也就是说，匹配时函数的定义和声明中的（  ）可以不同，其它必须完全相同。  
**A. 函数名称**  
**B. 参数名称**  
**C. 参数类型及顺序**  
**D. 返回类型**  

**答案：B**  
**题解**：函数声明和定义必须匹配返回类型、函数名、参数类型及顺序，参数名称可以不同。例如：  
```cpp
void f(int x);       // 声明  
void f(int num) { }  // 定义（参数名x→num，合法）
```  


### 28. 若一个函数的返回值类型为void，以下叙述正确的是_____。  
**A. 函数不能修改实际参数的值**  
**B. 函数返回值需要强类型转换**  
**C. 函数没有返回值**  
**D. 调用该函数不执行任何操作**  

**答案：C**  
**题解**：`void`类型函数表示没有返回值，不能使用`return`语句返回值（除非`return;`用于提前退出）。函数可通过指针或引用修改实参，且调用时会执行函数体中的操作。


### 29. 下面函数调用的语句中，一定不正确的是_____。  
**A. max(3, a+b);**  
**B. max(3,5);**  
**C. max(a ,b) ;**  
**D. max(int a,int b);**  

**答案：D**  
**题解**：函数调用时不能包含参数类型声明，D选项`max(int a,int b);`是函数声明的语法，而非调用。正确的调用应传入实际参数，如`max(a, b);`。


### 30. 下面关于形参与实参的说法中，不一定正确的是（  ）。  
**A. 形参与实参如果都是变量，则变量名称与数据类型必须完全相同**  
**B. 形参是函数的局部变量，函数调用完毕后被销毁**  
**C. 实参可以是常量、变量、表达式或其它函数调用的返回值**  
**D. 值传递时，实参的值传给形参，函数结束后形参无法修改实参**  

**答案：A**  
**题解**：形参与实参的数据类型必须兼容，但变量名称可以不同。例如实参为`int a`，形参为`int x`，名称不同但类型相同，是合法的。


### 31. 下列关于函数定义中return语句的描述，错误的是_____。  
**A. 函数通过return语句仅能返回一个值**  
**B. return语句用于结束当前函数，返回程序控制权**  
**C. 一个函数可以有多条return语句**  
**D. 一个函数中必须有且仅有一条return语句**  

**答案：D**  
**题解**：函数中可以有多条`return`语句（如分支结构中），也可以没有`return`语句（仅当返回类型为`void`时）。例如：  
```cpp
int f(int x) {
    if(x>0) return 1;
    else return -1;  // 多条return语句
}
void g() { }       // 无return语句，合法
```  


### 32. 函数返回值的类型是由_____决定的。  
**A. return语句中的表达式类型**  
**B. 调用时主调函数实参的类型**  
**C. 定义函数时指定的返回类型**  
**D. 调用时系统临时分配的类型**  

**答案：C**  
**题解**：函数返回值的类型由定义函数时指定的返回类型决定。若`return`语句的表达式类型与定义的返回类型不同，会自动转换为返回类型。例如：  
```cpp
double f() { return 1; }  // 1（int）会转为double返回
```  


### 33. 若有函数调用`fun(a+b,3,max(n-1,b))`，则fun的实参个数是_____。  
**A. 5**  
**B. 6**  
**C. 3**  
**D. 4**  

**答案：C**  
**题解**：实参是逗号分隔的表达式，`a+b`、`3`、`max(n-1,b)`为3个实参，无论表达式多复杂，逗号分隔的数量即为实参个数。


### 34. 下面说法中正确的是：在C/C++语言程序中_____。  
**A. 函数的定义和调用均可以嵌套**  
**B. 函数的定义和调用均不可嵌套**  
**C. 函数定义不可嵌套，但调用可以嵌套**  
**D. 函数定义可以嵌套，但调用不可嵌套**  

**答案：C**  
**题解**：C/C++不允许函数嵌套定义（函数内不能定义另一个函数），但允许函数嵌套调用（函数A调用函数B，函数B调用函数C）。


### 35. 下面定义了f与fun两个函数，当main函数中调用fun函数时，将出现的情况是（   ）。  
```cpp
void f(int n) {
    n=1;
}
void fun() {
    int n=0;
    f(n);
    printf("%d",n);
}
```  
**A. 输出1**  
**B. 输出0**  
**C. 输出不确定数**  
**D. 输出10**  

**答案：B**  
**题解**：`f(n)`采用值传递，形参`n`的修改不影响实参`fun`中的`n`，因此`n`仍为0，输出0。


### 36. 能够正常可靠实现交换两个整数值的函数定义的是（   ）。  
**A.**  
```cpp
void fun(int *x, int *y) {
    int *temp;
    *temp = *x;
    *x = *y;
    *y = *temp;
}
```  
**B.**  
```cpp
void fun(int x, int y) {
    int temp = x;
    x = y;
    y = temp;
}
```  
**C.**  
```cpp
void fun(int* x, int* y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}
```  
**D.**  
```cpp
void fun(int* x, int* y) {
    int *temp = x;
    x = y;
    y = temp;
}
```  

**答案：C**  
**题解**：  
- A错误：`int *temp`未初始化，`*temp = *x`会访问野指针，导致未定义行为；  
- B错误：值传递，无法修改实参；  
- C正确：通过指针修改指向的值，实现交换；  
- D错误：仅交换了指针本身，未修改指针指向的值，实参未改变。


### 37. 定义数组a的语句如下：`int a[5]={1,3,5};`，则对初始化值的说法正确的是________。  
**A. 将1、3、5依次赋给a[0]至a[2]**  
**B. 将1、3、5依次赋给a[1]、a[3]、a[5]**  
**C. 将1、3、5依次赋给a[3]至a[5]**  
**D. 数组访问越界**  

**答案：A**  
**题解**：数组初始化时，若初始值个数少于数组长度，剩余元素自动初始化为0。`a[5]`有5个元素，`{1,3,5}`初始化前3个元素，`a[0]=1`，`a[1]=3`，`a[2]=5`，`a[3]`和`a[4]`为0。


### 38. 已知函数原型`int max(int a[],int n);`，主函数中定义`int arr[5];`，调用max函数语法正确的是________。  
**A. int maxValue = max(a,5);**  
**B. int maxValue = max(int a[],5);**  
**C. int maxValue = max(arr,5);**  
**D. int maxValue = max(int arr[],5);**  

**答案：C**  
**题解**：函数调用时应传入数组名（代表首地址）和长度，`arr`是数组名，`5`是数组长度。A中`a`未定义，B和D中调用时不能包含参数类型声明。


### 39. 假设定义数组`int a[10];`，程序中使用`a[10]=1;`，表示________。  
**A. 向数组越界位置赋值，可能导致严重后果**  
**B. 将第一个元素赋值为1**  
**C. 将所有元素赋值为1**  
**D. 将最后一个元素赋值为1**  

**答案：A**  
**题解**：`int a[10]`的合法下标为0~9，`a[10]`访问越界，会读写非法内存，可能导致程序崩溃、数据破坏或未定义行为。


### 40. 若有说明：`int a[3][4]；`，对a数组元素的非法引用是_________。  
**A. a[0][4]**  
**B. a[4-2][0]**  
**C. a[0][2*1]**  
**D. a[1][3]**  

**答案：A**  
**题解**：二维数组`a[3][4]`的行下标0~2，列下标0~3。`a[0][4]`列下标越界（4≥4），非法；B中`4-2=2`（行合法），C中`2*1=2`（列合法），D中`a[1][3]`合法。


### 41. 若二维数组a有m列，则在a[i][j]前的元素个数为_______________。  
**A. j*m+i**  
**B. i*m+j+1**  
**C. i*m+j-1**  
**D. i*m+j**  

**答案：D**  
**题解**：二维数组按行优先存储，前`i`行共有`i*m`个元素，第`i`行中前`j`个元素有`j`个，因此总个数为`i*m + j`。


### 42. 折半查找函数中，【1】和【2】处应填入（ ）。  
```cpp
int search( int a[], int n, int key) {
    int bot=0,top=n-1,mid;
    while(bot<=top) {
        mid=bot+(top-bot)/2;
        if(a[mid]==key) return mid;
        else if(a[mid]>key) 【1】
        else 【2】
    }
    return -1;
}
```  
**A. 【1】bot=mid+1; 【2】top=mid-1;**  
**B. 【1】bot=mid; 【2】top=mid;**  
**C. 【1】top=mid-1; 【2】bot=mid+1;**  
**D. 【1】top=mid; 【2】bot=mid;**  

**答案：C**  
**题解**：折半查找中，若`a[mid] > key`，说明`key`在左半区，应将`top`设为`mid-1`；若`a[mid] < key`，说明`key`在右半区，应将`bot`设为`mid+1`。


### 43. 假设定义数组`int a[10];`，数组a的下标范围是0到9。访问a[10]可能出现的情况不包括【 】。  
**A. 编译不通过**  
**B. 运行正常**  
**C. 运行显示意外值**  
**D. 运行时异常退出**  

**答案：A**  
**题解**：数组越界访问是运行时错误，编译阶段无法检测，因此A错误。运行时可能读取/修改非法内存，导致意外值或程序崩溃。


### 44. 已知函数原型`int max(int a[],int n);`，主函数中定义`int arr[10];`，调用max函数语法正确的是【 】。（同第38题）  
**A. int maxValue = max(a,10);**  
**B. int maxValue = max(int a[],10);**  
**C. int maxValue = max(arr,10);**  
**D. int maxValue = max(int arr[],10);**  

**答案：C**  
**题解**：同第38题，数组名`arr`作为实参传递。


### 45. 下面对二维数组x的定义错误的是【 】。  
**A. int x[][3]={{0},{1},{1,2,3}};**  
**B. int x[][3]={0,1,2,3};**  
**C. int x[3][3]={{1,2,3},{1,2,3},{1,2,3}};**  
**D. int x[3][]= {{1,2,3},{1,2,3},{1,2,3}};**  

**答案：D**  
**题解**：二维数组定义时，列数不能省略，行数可以省略（由初始值推断）。D选项中`int x[3][]`省略了列数，非法；A、B中列数为3，合法；C中明确指定行列数，合法。


### 46. 若有说明：`int a[][3]={1,2,3,4,5,6,7,8,9,10};`，则a数组第一维的大小是【 】。  
**A. 3**  
**B. 4**  
**C. 10**  
**D. 不确定**  

**答案：B**  
**题解**：二维数组初始化时，列数为3，总元素个数为10。第一维大小=总元素数 / 列数（向上取整），即10/3=3余1，因此第一维大小为4，数组为`a[4][3]`，前3行每行3个元素，第4行1个元素（其余为0）。


### 47. 下面的语句定义了两个字符数组sa和sb，说法正确的是【 】。  
```cpp
char sa[]="hello";
char sb[]={'h', 'e', 'l', 'l', 'o'};
```  
**A. 数组sa和sb是同一内存**  
**B. 数组sa的长度等于sb的长度**  
**C. 数组sa的长度大于sb的长度**  
**D. 数组sa的长度小于sb的长度**  

**答案：C**  
**题解**：`"hello"`是字符串字面量，包含5个字符和1个终止符`\0`，因此`sa`的长度为6；`sb`显式初始化5个字符，无终止符，长度为5。故`sa`的长度大于`sb`。


### 48. 已知有定义`char s1[20],s2[20];`，判断s1是否大于s2时，应当使用【 】。  
**A. if (s1>s2)**  
**B. if (strcmp (s1,s2))**  
**C. if (strcmp (s1,s2)<0)**  
**D. if (strcmp (s1,s2)>0)**  

**答案：D**  
**题解**：`strcmp(s1, s2)`函数比较字符串：  
- 返回值>0：s1 > s2；  
- 返回值=0：s1 == s2；  
- 返回值<0：s1 < s2。  
因此判断s1>s2需用`strcmp(s1,s2)>0`。


### 49. 定义字符数组s，下列语句执行后输出不是“How are you！”的是【 】。  
**A. char s[20]; cin >> s; 输入How are you！回车**  
**B. char s[20]; cin.getline(s,20); 输入How are you！回车**  
**C. char s[20]; strcpy(s,"How are you!");**  
**D. char s[20]="How are you!";**  

**答案：A**  
**题解**：`cin >> s`遇到空格会停止读取，输入`How are you！`时，仅读取`How`，后续字符被忽略。B、C、D均能正确存储完整字符串。


### 50. 下面对C++字符数组的描述中错误的是【 】。  
**A. 不能用关系运算符比较字符串**  
**B. 字符数组中的字符串可以整体输入、输出**  
**C. 可以通过“=”对字符数组整体赋值**  
**D. 字符数组可以存放字符串**  

**答案：C**  
**题解**：C++不允许通过`=`对字符数组整体赋值，只能逐个元素赋值或初始化。例如：  
```cpp
char s[20];
s = "hello";  // 错误，不能直接赋值
```  
正确做法是使用`strcpy`或初始化：  
```cpp
char s[20] = "hello";  // 初始化合法
strcpy(s, "hello");    // 复制合法
```  


### 51. 若有定义`char s[20]="programming",*p=s;`，不能代表字符g的表达式是【 】。  
**A. *p+3**  
**B. s[3]**  
**C. p[3]**  
**D. p+=3,*p**  

**答案：A**  
**题解**：`s="programming"`中，字符索引如下：  
- s[0]='p', s[1]='r', s[2]='o', s[3]='g', ...  
- A选项`*p+3`：`*p`是`s[0]='p'`，`'p'+3`是字符`'s'`（ASCII码+3），不是`'g'`；  
- B选项`s[3]`= 'g'；  
- C选项`p[3]`等价于`s[3]`= 'g'；  
- D选项`p+=3`后`p`指向`s[3]`，`*p`= 'g'。


### 52. C++中，文件操作完成后关闭文件流对象ifs需使用【 】方法。  
**A. end**  
**B. fail**  
**C. close**  
**D. open**  

**答案：C**  
**题解**：文件流对象的`close()`方法用于关闭文件，释放资源。`open()`用于打开文件，`fail()`检查操作是否失败，`end`无此方法。


#### 作者 ： 
工程技术学院 安全工程 24 级 
**江旭** 
***2025年6月***

#### 更多真题详见
**https://github.com/jiangxu05/notes/tree/master**