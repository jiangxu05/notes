# 指针

## 题目 1
【单选题】定义实型变量a和指针p，要让p指向a，以下不正确的有【】。

### 选项分析
- **选项A**
  ```c
  double a = 5;
  double *p;
  p = &a;
  ```
> 先把实型变量a定义好并赋值为 5，接着定义一个指向 double 类型的指针p，最后让指针p指向变量a的地址。

- **选项B**
  ```c
  double a = 5;
  double *p = &a;
  ```
> 在定义实型变量a并赋值为 5 之后，在定义指针p的同时就将其初始化为变量a的地址。

- **选项C**
  ```c
  double a = 5;
  double *p;
  *p = &a;  // [!error]
  ```
> 先定义实型变量a并赋值为 5，再定义指针p，然而错误地把a的地址赋给了p所指向的内存位置（*p）。
> 错误点：指针p在使用之前没有被初始化，它指向的是一个随机的内存地址，直接对其解引用会造成内存访问越界。
> double a = 5.0;  // a的值=5.0，地址=&a（0x7ffe53a0）
> double *p;       // p的值=随机地址（如0x0）
> *p = &a;         // 错误！试图将&a（0x7ffe53a0）写入p指向的随机内存
> // 最终：p仍指向随机地址，*p（随机内存）被错误赋值为0x7ffe53a0

- **选项D**
  ```c
  double a = 5, *p = &a;
  ```
> 在同一行里定义了实型变量a和指针p，并且在定义指针p时就将其初始化为变量a的地址。

- **选项E**
  ```c
  double a = 5, *p;
  p = &a;
  ```
> 在同一行定义实型变量a和指针p之后，再让指针p指向变量a的地址。
---

## 题目2
【单选题】下面函数的功能为【】。

```c
void swap(int *p1, int *p2) 
{ 
    int t;
    t = *p1;
    *p1 = *p2; 
    *p2 = t; 
}
```

### 选项
- **A** 交换 *p1 和 *p2 的值  
- **B** 可能造成系统故障，因为使用了空指针  
- **C** 交换 *p1 和 *p2 的地址  
- **D** 正确，但无法改变 *p1 和 *p2 的值  

---

## 答案解析
✅ 正确答案：A（交换 *p1 和 *p2 的值）**

### 完整解析

#### 1. 函数功能分析
**参数分析**：
```c
int *p1, int *p2  // 接收两个整型指针
```

**执行流程**：
1. `int t;`：声明临时整型变量
2. `t = *p1;`：保存p1指向的值
3. `*p1 = *p2;`：将p2的值赋给p1指向的内存
4. `*p2 = t;`：将临时值赋给p2指向的内存


#### 2. 选项正确性分析
- **选项A正确**：
  - 通过解引用操作交换指针指向的值
  - 典型用例：
    ```c
    int a=10, b=20;
    swap(&a, &b);  // a=20, b=10
    ```

- **选项B错误**：
  - 空指针问题是调用时的风险，非函数本身功能
  - 功能描述应聚焦设计意图而非使用风险

- **选项C错误**：
  - 混淆概念：`*p1`表示值，`p1`表示地址
  - 函数没有修改指针变量本身存储的地址

- **选项D错误**：
  - 自相矛盾：若函数正确则必然能改变值
  - 通过指针解引用直接修改内存内容

#### 3. 关键知识点总结
1. **指针操作本质**：
   ```c
   *p1 = ...  // 修改指针指向的内存内容
   p1 = ...   // 修改指针本身存储的地址
   ```

2. **正确调用方式**：
   ```c
   int x=5, y=10;
   swap(&x, &y);  // 必须传递有效内存地址
   ```
## 题目3
【单选题】下面程序的输出结果为【】。

```cpp
int fun(char *s) 
{   
    char *p = s; 
    while(*p != 0)  
        p++; 
    return (p - s); 
}

int main()
{   
    char str[] = "dev-c++";
    cout << fun(str) << endl;
    return 0;
}
```

### 选项
- **A** 3  
- **B** 7  
- **C** 1  
- **D** 语法错误  

---

## 答案解析
✅ **正确答案：B（7）**

### 题目讲解
本题考查C++中指针和字符串操作的知识。程序定义了一个函数`fun`用于计算字符串长度（不包括结尾空字符），并在`main`函数中输出结果。

#### 1. 函数功能分析
**参数**：
```cpp
char *s  // 指向字符串开头的指针
```

**执行流程**：
1. `char *p = s;`：声明指针p并初始指向字符串起始位置
2. `while(*p != 0)`：循环检查p指向的字符是否为空字符'\0'
3. `p++;`：将指针p向后移动一个字符
4. `return (p - s);`：返回指针差值（字符个数）

#### 2. main函数执行过程
```cpp
char str[] = "dev-c++";  // 实际存储：d e v - c + + \0
```
- 字符串可见字符7个，结尾隐式包含空字符
- `fun(str)`调用过程：
  - s指向'd'的位置（地址0）
  - p经过7次移动到达'\0'的位置（地址7）
  - 指针差值：7 - 0 = 7

#### 3. 选项分析
- **B正确**：
  - 字符串"dev-c++"实际长度7字符
  - 函数正确返回指针移动次数

- **A错误**：
  - 误判字符串为"dev"（实际是"dev-c++"）

- **C错误**：
  - 无对应逻辑关系

- **D错误**：
  - 代码语法正确（标准输出和字符串定义规范）

## 题目4
【单选题】如果要动态分配一个能存储1个int型变量的内存单元，初值为5，以下正确的是【】。

### 选项
- **A**  
  ```cpp
  int *p = new int<5>;
  ```
  
- **B**  
  ```cpp
  int *p = new int{5};
  ```

- **C**  
  ```cpp
  int *p = new int(5);
  ```

- **D**  
  ```cpp
  int *p = new int[5];
  ```

---

## 答案解析
✅ **正确答案：B、C（根据C++版本不同）**

### 选项分析
**选项A**：
```cpp
int *p = new int<5>;  // [!error]
```
- ❌ 语法错误：尖括号`< >`用于模板参数（如`new vector<int>(5)`）
- ➥ 混淆了模板实例化与动态内存初始化语法

**选项B**：
```cpp
int *p = new int{5};
```
- ✅ C++11起支持的列表初始化（uniform initialization）
- ✔️ 正确分配单个int并初始化为5

**选项C**：
```cpp
int *p = new int(5);
```
- ✅ 传统C++标准初始化方式
- ✔️ 正确分配单个int并初始化为5

**选项D**：
```cpp
int *p = new int[5];
```
- ❌ 分配包含5个int的数组
- ➥ 不符合"单个int变量"要求，且未设置初值5

---

## 关键知识点
1. **new运算符初始化方式**：
   ```cpp
   new int(5);   // 传统括号初始化
   new int{5};   // C++11列表初始化
   ```

2. **错误类型辨析**：
   - `< >` → 模板参数专用
   - `[ ]` → 数组分配标识
   - 未初始化 → 如`new int`会得到随机值

---

## 补充说明
1. **版本兼容性**：
   - C++11及以上：B、C都正确
   - 传统C++：仅C正确

2. **执行效果**：
   ```cpp
   int *p1 = new int(5);  // *p1 == 5
   int *p2 = new int{5};  // *p2 == 5 (C++11+)
   ```

3. **建议选择**：
   - 考试环境不确定时选**C**（兼容所有版本）
   - 现代C++开发可同时接受B、C






### 题目7
【单选题】`float *p = new float[10];`下面对应的delete用法正确的是【】。

- **A**  
  ```cpp
  delete p[10];
  ```

- **B**  
  ```cpp
  delete p;
  ```

- **C**  
  ```cpp
  delete float;
  ```

- **D**  
  ```cpp
  delete[] p;
  ```

---

## 题目解析
**考查重点**：C++动态内存释放的正确语法，区分`delete`和`delete[]`的用法

### 关键知识点
1. **内存操作对比表**：
   | 分配方式                | 正确释放方式  | 错误释放后果                  |
   |-----------------------|-------------|----------------------------|
   | `new float[10]`（数组） | `delete[] p` | 完整释放10个float的内存       |
   | `new float`（单个变量） | `delete p`   | 释放单个float的内存           |
   | 错误示例（如选项C）      | -           | 编译失败                     |

2. **语法规则**：
   - `new[]`和`delete[]`必须配对使用
   - `delete`后必须跟指针变量名，不能是类型名

### 选项分析
**选项A**：
```cpp
delete p[10];  // [!error]
```
- ❌ 双重错误：
  1. 下标越界（有效范围是p[0]~p[9]）
  2. 语法错误（delete操作对象必须是指针）

**选项B**：
```cpp
delete p;  // [!error]
```
- ❌ 类型不匹配：
  - 数组分配应使用`delete[]`
  - 仅释放第一个元素内存，造成内存泄漏

**选项C**：
```cpp
delete float;  // [!error]
```
- ❌ 语法错误：
  - 操作对象必须是变量指针
  - 不能直接使用类型名

**选项D**：
```cpp
delete[] p;  // ✅
```
- ✔️ 完全正确：
  - 精确匹配数组释放方式
  - 完整释放10个float的内存空间

---

## 正确答案
✅ **正确答案：D（delete[] p）**

💡 **记忆技巧**：
> `new[]`和`delete[]`的方括号`[]`就像数组的"身份证"，必须成对出现！此知识点是C++面试高频考点，务必掌握匹配原则以避免内存泄漏。

---

## 补充说明
1. **最佳实践**：
   ```cpp
   // 分配与释放严格对应
   float* arr = new float[10];  // 分配数组
   // ...使用数组...
   delete[] arr;                // 正确释放

   float* val = new float;      // 分配单个变量
   // ...使用变量...
   delete val;                  // 正确释放
   ```

## 题目8
【单选题】下面函数中，无法实现主调函数交换两个整数的值的功能的是【】。

### 选项
- **A**  
  ```cpp
  void fun1(int& x, int& y) {
      int temp = x;
      x = y;
      y = temp;
  }
  ```

- **B**  
  ```cpp
  void fun4(int* x, int* y) {
      int* temp = new int;
      *temp = *x;
      *x = *y;
      *y = *temp;
  }
  ```

- **C**  
  ```cpp
  void fun3(int x, int y) {
      int temp = x;
      x = y;
      y = temp;
  }
  ```

- **D**  
  ```cpp
  void fun2(int* x, int* y) {
      int temp = *x;
      *x = *y;
      *y = temp;
  }
  ```

---

## 题目解析
**考查重点**：函数参数传递方式对变量交换的影响

### 选项分析
- **选项A**  
  ✅ **正确实现**  
  ```cpp
  void fun1(int& x, int& y)  // 引用传递（直接操作原变量）
  ```
  - x 和 y 是实参的别名
  - 交换操作直接影响主调函数中的变量

- **选项B**  
  ✅ **功能正确但存在内存泄漏**  
  ```cpp
  void fun4(int* x, int* y)  // 指针传递（通过地址修改原值）
  ```
  - `*x` 和 `*y` 解引用操作直接修改指针指向的内存
  - 问题：`new int`未释放，但交换功能正确

- **选项C**  
  ❌ **无法实现交换**  
  ```cpp
  void fun3(int x, int y)  // 值传递（操作的是副本）
  ```
  - 函数内交换的只是形参副本
  - 不影响主调函数的实参

- **选项D**  
  ✅ **正确实现**  
  ```cpp
  void fun2(int* x, int* y)  // 指针传递（通过地址修改原值）
  ```
  - `*x` 和 `*y` 解引用操作直接修改原变量

---

### 关键对比表
| 选项 | 参数类型      | 内存操作方式               | 能否交换 |
|------|-------------|--------------------------|--------|
| A    | int&（引用） | 直接操作原始变量           | ✅      |
| B    | int*（指针） | 解引用修改指针目标值       | ✅      |
| C    | int（值）    | 操作副本，不影响原始值     | ❌      |
| D    | int*（指针） | 解引用修改指针目标值       | ✅      |

---

### 常见错误分析
1. **值传递陷阱（选项C）**：
   ```cpp
   int a=1, b=2;
   fun3(a, b);  // 调用后 a仍为1, b仍为2
   ```

2. **正确用法对比**：
   ```cpp
   fun1(a, b);    // 引用：a=2, b=1
   fun2(&a, &b);  // 指针：a=2, b=1
   fun4(&a, &b);  // 指针：a=2, b=1（有内存泄漏但结果正确）
   ```

---

## 正确答案
✅ **正确答案：C（fun3）**

> 📌 **核心原则**：  
> 要修改主调函数的变量，必须传递变量的地址（指针）或别名（引用）。值传递只能读取原始值，无法写入修改。其他选项都能实现交换，只有C无法实现。