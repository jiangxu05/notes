// 在一条无限长的路上，有一排无限长的路灯，编号为 1,2,3,4,…。
// 每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。
// 在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：
// 指定两个数，a,t（a 为实数，t 为正整数）。将编号为 ⌊a⌋,⌊2×a⌋,⌊3×a⌋,…,⌊t×a⌋ 的灯的开关各按一次。其中 ⌊k⌋ 表示实数 k 的整数部分
// 在小明进行了 n 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。
// 幸好，小明还记得之前的 n 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？

// 输入格式
// 第一行一个正整数 n，表示 n 次操作。

// 接下来有 n 行，每行两个数，ai,ti。其中 ai 是实数，小数点后一定有 6 位，ti 是正整数。

// 输出格式
// 仅一个正整数，那盏开着的灯的编号。

// 输入 
// 3
// 1.618034 13
// 2.618034 7
// 1.000000 21
// 输出 
// 20

#include <iostream>
#include <cmath> // 用于floor函数
#include <vector>
using namespace std;

int main() {
    int caozuo_cishu;
    cin >> caozuo_cishu;
    
    // 记录每个灯被按的次数,只需要记录到最大可能的灯编号
    // 最大可能编号 = max(floor(ti * ai))
    vector<int> deng_zhuangtai(10001, 0); // 初始化为0,表示关闭状态
    
    // 处理每次操作
    for(int i = 0; i < caozuo_cishu; i++) {
        double a;
        int t;
        cin >> a >> t;
        
        // 对于每个倍数,计算灯的编号并改变其状态
        for(int j = 1; j <= t; j++) {
            // floor函数用来向下取整,比如:
            // floor(3.7) = 3
            // floor(2.1) = 2
            // floor(-3.7) = -4 
            int deng_bianhao = floor(j * a); // 计算灯的编号:j*a可能是小数,用floor取整得到灯编号//其实也可以（int）
            deng_zhuangtai[deng_bianhao]++; // 记录按开关的次数
        }
    }
    
    // 找到最后亮着的灯
    // 按了奇数次的灯是开着的,偶数次是关着的
    for(int i = 1; i <= 10000; i++) {
        if(deng_zhuangtai[i] % 2 == 1) { // 如果按了奇数次
            cout << i << endl;
            break;
        }
    }
    
    return 0;
}
//如果运行时RE，数组越界，直接把大小变大就行啦。。。把【10001】多加几个000就行。
