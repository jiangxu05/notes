# 字符串处理核心知识点

## 1. 字符类型判断与处理

### 核心代码
```cpp
// 找到单词的起始位置
while (pos < article.length() && !isalpha(article[pos])) pos++;
if (pos >= article.length()) break;
```

### isalpha() 函数详解
**功能特性**：
- 判断字符是否为字母（a-z/A-Z）
- 返回非零值（通常为1）表示是字母
- 返回0表示非字母（数字/标点/空格等）

**使用方法**：
```cpp
#include <cctype>  // C++标准库
// 或
#include <ctype.h> // C语言标准库

int main() {
    char c = 'A';
    if (isalpha(c)) {  // 返回true
        // 字母处理逻辑
    }
    return 0;
}
```

**相关函数集**：
| 函数名       | 功能描述                   |
|--------------|--------------------------|
| `isdigit()`  | 检查数字字符（0-9）        |
| `isalnum()`  | 检查字母或数字字符         |
| `islower()`  | 检查小写字母（a-z）        |
| `isupper()`  | 检查大写字母（A-Z）        |
| `isspace()`  | 检查空白字符（空格/制表符等）|
| `ispunct()`  | 检查标点符号               |
| `isprint()`  | 检查可打印字符             |

**注意事项**：
- 使用前需包含对应头文件
- 检查结果受当前区域设置影响
- 建议配合tolower/toupper使用实现大小写无关比较

---

## 2. 凯撒密码实现

### 核心算法
```cpp
for (char &c : str) {
    int offset = (c - 'a' + n) % 26;  // 保证在字母范围内
    c = 'a' + offset;  // 字符转换
}
```

### 算法解析
**步骤拆解**（以字符'c'，位移3为例）：
1. **字符转数字**：`'c' - 'a' = 2`
2. **位移计算**：`2 + 3 = 5`
3. **取模运算**：`5 % 26 = 5`
4. **转回字符**：`'a' + 5 = 'f'`

**循环特性**：
```
原始序列：a b c ... x y z
位移3后：d e f ... a b c
```

**实例演示**：
| 原字符 | 计算过程          | 结果字符 |
|--------|-------------------|----------|
| a      | (0+5)%26 → 5      | f        |
| x      | (23+5)%26 → 2     | c        |
| z      | (25+1)%26 → 0     | a        |

---

## 3. 质数判断优化

### 实现代码
```cpp
bool isprime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
```

### 原理解析
**数学基础**：
- 若n有因数a，则必存在对应因数b = n/a
- 当a ≤ √n时，必有b ≥ √n
- 只需检查2到√n的范围即可

**复杂度对比**：
| 检查范围  | 时间复杂度 | 示例n=10000 |
|----------|------------|-------------|
| 2~n      | O(n)       | 10000次     |
| 2~√n     | O(√n)      | 100次       |

**注意事项**：
- 需特殊处理n ≤ 1的情况
- i*i的写法比sqrt(n)更高效
- 可预先生成质数表优化重复计算

---

## 4. 极值初始化问题

### 问题代码
```cpp
int maxn = 0, minn = 100; // 错误初始化
int count[26] = {0};

for (int i = 0; i < 26; i++) {
    if (count[i] > maxn) maxn = count[i];
    if (count[i] < minn && count[i] != 0) minn = count[i];
}
```

### 优化方案
```cpp
#include <climits>

int maxn = 0, minn = INT_MAX;  // 正确初始化

for (int i = 0; i < 26; i++) {
    if (count[i] > maxn) maxn = count[i];
    if (count[i] > 0 && count[i] < minn) {
        minn = count[i];
    }
}
```

**关键改进点**：
1. 使用`INT_MAX`代替固定值100
2. 增加`count[i] > 0`的条件判断
3. 包含必要的头文件`<climits>`

**对比分析**：
| 初始化方式 | 优点                  | 缺点                  |
|------------|-----------------------|-----------------------|
| minn=100   | 简单直观              | 可能无法正确更新      |
| INT_MAX    | 保证正确初始化        | 需要包含标准库头文件  |
